<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RabbitMQ</title>
    <url>/2022/05/10/RabbitMQ/</url>
    <content><![CDATA[<p>@[TOC] </p>
<h1 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h1><h2 id="1-1-MQ的相关概念"><a href="#1-1-MQ的相关概念" class="headerlink" title="1.1. MQ的相关概念"></a>1.1. MQ的相关概念</h2><h3 id="1-1-1-什么是MQ"><a href="#1-1-1-什么是MQ" class="headerlink" title="1.1.1. 什么是MQ"></a>1.1.1. 什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务</p>
<h2 id="1-1-2-为什么要用MQ"><a href="#1-1-2-为什么要用MQ" class="headerlink" title="1.1.2. 为什么要用MQ"></a>1.1.2. 为什么要用MQ</h2><p>1.流量消峰<br>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。<br>2.应用解耦<br>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。<br><img src="https://img-blog.csdnimg.cn/440d96ac7ad744f6a5b80d7a21cb378f.png" alt="在这里插入图片描述">3.异步处理<br>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>
<p><img src="https://img-blog.csdnimg.cn/7a84b9fad63146c4abd7b9b8165a0a06.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-3-MQ-的分类"><a href="#1-1-3-MQ-的分类" class="headerlink" title="1.1.3. MQ 的分类"></a>1.1.3. MQ 的分类</h3><p>几种常见MQ的对比：<br><img src="https://img-blog.csdnimg.cn/c791236c8a9a471592e9092ea951ff88.png" alt="在这里插入图片描述">追求可用性：Kafka、 RocketMQ 、RabbitMQ<br>追求可靠性：RabbitMQ、RocketMQ<br>追求吞吐能力：RocketMQ、Kafka<br>追求消息低延迟：RabbitMQ、Kafka</p>
<h2 id="1-2-RabbitMQ"><a href="#1-2-RabbitMQ" class="headerlink" title="1.2. RabbitMQ"></a>1.2. RabbitMQ</h2><h3 id="1-2-1-RabbitMQ-的概念"><a href="#1-2-1-RabbitMQ-的概念" class="headerlink" title="1.2.1. RabbitMQ 的概念"></a>1.2.1. RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p>
<h3 id="1-2-2-四大核心概念"><a href="#1-2-2-四大核心概念" class="headerlink" title="1.2.2. 四大核心概念"></a>1.2.2. 四大核心概念</h3><p><strong>生产者</strong><br>产生数据发送消息的程序是生产者</p>
<p><strong>交换机</strong><br>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p>
<p><strong>队列</strong><br>    队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p>
<p><strong>消费者</strong><br>    消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>
<h3 id="1-2-3-RabbitMQ-核心部分"><a href="#1-2-3-RabbitMQ-核心部分" class="headerlink" title="1.2.3. RabbitMQ 核心部分"></a>1.2.3. RabbitMQ 核心部分</h3><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：<br><img src="https://img-blog.csdnimg.cn/b7dc34ae4e7f4147a45e2d0339a6190f.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-4-各个名词介绍"><a href="#1-2-4-各个名词介绍" class="headerlink" title="1.2.4. 各个名词介绍"></a>1.2.4. 各个名词介绍</h3><p><img src="https://img-blog.csdnimg.cn/3d321c15c0a94bb3b20bb025a56b9d15.png" alt="在这里插入图片描述"><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker<br><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等<br><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接<br><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一Connection，在消息量大的时候建立 TCPConnection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的<em><strong>Connection 极大减少了操作系统建立 TCP connection 的开销</strong></em><br><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout(multicast)<br><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走<br><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保<br>存到 exchange 中的查询表中，用于 message 的分发依据</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2022/05/09/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="芭比Q"><a href="#芭比Q" class="headerlink" title="芭比Q"></a>芭比Q</h2><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊</p>
]]></content>
  </entry>
</search>
