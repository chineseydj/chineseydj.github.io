<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2022/05/10/RabbitMQ/"/>
    <url>/2022/05/10/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h1><h2 id="1-1-MQ的相关概念"><a href="#1-1-MQ的相关概念" class="headerlink" title="1.1. MQ的相关概念"></a>1.1. MQ的相关概念</h2><h3 id="1-1-1-什么是MQ"><a href="#1-1-1-什么是MQ" class="headerlink" title="1.1.1. 什么是MQ"></a>1.1.1. 什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务</p><h2 id="1-1-2-为什么要用MQ"><a href="#1-1-2-为什么要用MQ" class="headerlink" title="1.1.2. 为什么要用MQ"></a>1.1.2. 为什么要用MQ</h2><p>1.流量消峰<br>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。<br>2.应用解耦<br>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。<br><img src="https://img-blog.csdnimg.cn/440d96ac7ad744f6a5b80d7a21cb378f.png" alt="在这里插入图片描述">3.异步处理<br>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="https://img-blog.csdnimg.cn/7a84b9fad63146c4abd7b9b8165a0a06.png" alt="在这里插入图片描述"></p><h3 id="1-1-3-MQ-的分类"><a href="#1-1-3-MQ-的分类" class="headerlink" title="1.1.3. MQ 的分类"></a>1.1.3. MQ 的分类</h3><p>几种常见MQ的对比：<br><img src="https://img-blog.csdnimg.cn/c791236c8a9a471592e9092ea951ff88.png" alt="在这里插入图片描述">追求可用性：Kafka、 RocketMQ 、RabbitMQ<br>追求可靠性：RabbitMQ、RocketMQ<br>追求吞吐能力：RocketMQ、Kafka<br>追求消息低延迟：RabbitMQ、Kafka</p><h2 id="1-2-RabbitMQ"><a href="#1-2-RabbitMQ" class="headerlink" title="1.2. RabbitMQ"></a>1.2. RabbitMQ</h2><h3 id="1-2-1-RabbitMQ-的概念"><a href="#1-2-1-RabbitMQ-的概念" class="headerlink" title="1.2.1. RabbitMQ 的概念"></a>1.2.1. RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><h3 id="1-2-2-四大核心概念"><a href="#1-2-2-四大核心概念" class="headerlink" title="1.2.2. 四大核心概念"></a>1.2.2. 四大核心概念</h3><p><strong>生产者</strong><br>产生数据发送消息的程序是生产者</p><p><strong>交换机</strong><br>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><p><strong>队列</strong><br>    队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><p><strong>消费者</strong><br>    消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p><h3 id="1-2-3-RabbitMQ-核心部分"><a href="#1-2-3-RabbitMQ-核心部分" class="headerlink" title="1.2.3. RabbitMQ 核心部分"></a>1.2.3. RabbitMQ 核心部分</h3><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：<br><img src="https://img-blog.csdnimg.cn/b7dc34ae4e7f4147a45e2d0339a6190f.png" alt="在这里插入图片描述"></p><h3 id="1-2-4-各个名词介绍"><a href="#1-2-4-各个名词介绍" class="headerlink" title="1.2.4. 各个名词介绍"></a>1.2.4. 各个名词介绍</h3><p><img src="https://img-blog.csdnimg.cn/3d321c15c0a94bb3b20bb025a56b9d15.png" alt="在这里插入图片描述"><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker<br><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等<br><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接<br><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一Connection，在消息量大的时候建立 TCPConnection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的<em><strong>Connection 极大减少了操作系统建立 TCP connection 的开销</strong></em><br><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout(multicast)<br><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走<br><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保<br>存到 exchange 中的查询表中，用于 message 的分发依据</p><h3 id="1-2-5-安装"><a href="#1-2-5-安装" class="headerlink" title="1.2.5. 安装"></a>1.2.5. 安装</h3><h4 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1.单机部署"></a>1.单机部署</h4><p>我们在Centos7虚拟机中使用Docker来安装。</p><h5 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1.下载镜像"></a>1.1.下载镜像</h5><p>方式一：在线拉取</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><p>方式二：从本地加载<br>下载mq.tar安装包，上传到虚拟机中后，使用命令加载镜像即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker load -<span class="hljs-selector-tag">i</span> mq<span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure><h5 id="1-2-安装MQ"><a href="#1-2-安装MQ" class="headerlink" title="1.2.安装MQ"></a>1.2.安装MQ</h5><p>执行下面的命令来运行MQ容器：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_USER=ydj <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_PASS=<span class="hljs-number">123456</span> <span class="hljs-string">\</span><br> --name mq <span class="hljs-string">\</span><br> --hostname mq1 <span class="hljs-string">\</span><br> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> <span class="hljs-string">\</span><br> -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> <span class="hljs-string">\</span><br> -d <span class="hljs-string">\</span><br> rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><h4 id="2-集群部署"><a href="#2-集群部署" class="headerlink" title="2.集群部署"></a>2.集群部署</h4><p>接下来，我们看看如何安装RabbitMQ的集群。</p><h5 id="2-1-集群分类"><a href="#2-1-集群分类" class="headerlink" title="2.1.集群分类"></a>2.1.集群分类</h5><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p><ul><li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li><li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</li></ul><p>  <strong>我们先来看普通模式集群。</strong></p><h5 id="2-2-设置网络"><a href="#2-2-设置网络" class="headerlink" title="2.2.设置网络"></a>2.2.设置网络</h5><p>首先，我们需要让3台MQ互相知道对方的存在。<br>分别在3台机器中，设置 /etc/hosts文件，添加如下内容：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.150.101</span> mq1<br><span class="hljs-number">192.168.150.102</span> mq2<br><span class="hljs-number">192.168.150.103</span> mq3<br></code></pre></td></tr></table></figure><p>并在每台机器上测试，是否可以ping通对方：</p><h1 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h1><p>在本教程的这一部分中，我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印<br>出来的消费者。我们将介绍 Java API 中的一些细节。在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代表使用者保留的消息缓冲区<br>     <img src="https://img-blog.csdnimg.cn/28d994be7ccf4b5db58700d917af274f.png" alt="在这里插入图片描述"></p><h2 id="2-1-API代码"><a href="#2-1-API代码" class="headerlink" title="2.1 API代码"></a>2.1 API代码</h2><p>pom文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependencies&gt;<br>        &lt;!--rabbitmq 依赖客户端--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br>            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;<br>            &lt;version&gt;5.8.0&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!--操作文件流的一个依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;commons-io&lt;/groupId&gt;<br>            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;<br>            &lt;version&gt;2.6&lt;/version&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>    &lt;!--指定 jdk 编译版本--&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;source&gt;8&lt;/source&gt;<br>                    &lt;target&gt;8&lt;/target&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME= <span class="hljs-string">&quot;hello&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.80.130&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;ydj&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        System.out.println(<span class="hljs-string">&quot;等待消息接收&quot;</span>);<br>        <span class="hljs-comment">//推送的消息如何进行消费的接口回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag,delivery)-&gt;&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(message);<br>        &#125;;<br>        <span class="hljs-comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;消息消费被中断&quot;</span>);<br>        &#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消费者消费消息</span><br><span class="hljs-comment">         * 1.消费哪个队列</span><br><span class="hljs-comment">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span><br><span class="hljs-comment">         * 3.消费者未成功消费的回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, deliverCallback, cancelCallback);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME= <span class="hljs-string">&quot;hello&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.80.130&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;ydj&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 生成一个队列</span><br><span class="hljs-comment">         * 1.队列名称</span><br><span class="hljs-comment">         * 2.队列里面的消息是否持久化 默认消息存储在内存中</span><br><span class="hljs-comment">         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span><br><span class="hljs-comment">         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span><br><span class="hljs-comment">         * 5.其他参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(QUEUE_NAME,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,world&quot;</span>;<br><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;发送完毕&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-注解式开发"><a href="#2-2-注解式开发" class="headerlink" title="2.2 注解式开发"></a>2.2 注解式开发</h2><p>pom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>           &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;<br>           &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;<br>           &lt;scope&gt;test&lt;/scope&gt;<br>       &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">ydj</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.130</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span>  <span class="hljs-comment"># 虚拟主机</span><br></code></pre></td></tr></table></figure><p>测试类中消息发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    RabbitTemplate rabbitTemplate;<br>    <span class="hljs-comment">//生产者</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueuePublishers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,rabbitMQ&quot;</span>;<br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;hello&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接收到的消息：&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3总结"><a href="#2-3总结" class="headerlink" title="2.3总结"></a>2.3总结</h2><p>SpringAMQP如何发送消息？</p><ol><li>引入amqp的starter依赖</li><li>配置RabbitMQ地址</li><li>利用RabbitTemplate的convertAndSend方法</li></ol><p> SpringAMQP如何接收消息？</p><ul><li>引入amqp的starter依赖</li><li>配置RabbitMQ地址</li><li>定义类，添加@Component注解类中声明方法，添加@RabbitListener注解，方法参数就时消息<br>注意：消息一旦消费就会从队列删除，RabbitMQ没有消息回溯功能<h1 id="3-Work-Queues"><a href="#3-Work-Queues" class="headerlink" title="3. Work Queues"></a>3. Work Queues</h1>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。<h2 id="3-1-轮循分发消息"><a href="#3-1-轮循分发消息" class="headerlink" title="3.1. 轮循分发消息"></a>3.1. 轮循分发消息</h2>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。</li></ul><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Work01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>       <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag,delivery)-&gt;&#123;<br>           System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody()));<br>       &#125;;<br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag)-&gt;&#123;<br>            System.out.println(consumerTag+<span class="hljs-string">&quot;消费者取消消费接口调用逻辑&quot;</span>);<br>        &#125;;<br>        System.out.println(<span class="hljs-string">&quot;c2等待接收消息......&quot;</span>);<br>        channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">true</span>,deliverCallback,cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>开启2个work</strong><br><img src="https://img-blog.csdnimg.cn/186cb4138ab24b72a6f82c7ed0bb01b4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9068ca9706ea4fc18264f8413a889df2.png" alt="在这里插入图片描述"><br>修改代码运行即可<br><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br><span class="hljs-comment">//        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> scanner.next();<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;发送消息完成&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-4-结果展示"><a href="#3-1-4-结果展示" class="headerlink" title="3.1.4. 结果展示"></a>3.1.4. 结果展示</h3><p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息<br><img src="https://img-blog.csdnimg.cn/3f89d4ee6be34e23b8e6f8892626db1e.png" alt="在这里插入图片描述"></p><h2 id="3-2-消息应答"><a href="#3-2-消息应答" class="headerlink" title="3.2. 消息应答"></a>3.2. 消息应答</h2><h3 id="3-2-1-概念"><a href="#3-2-1-概念" class="headerlink" title="3.2.1. 概念"></a>3.2.1. 概念</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。<br>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，<strong>消息应答就是:消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p><h3 id="3-2-2-自动应答"><a href="#3-2-2-自动应答" class="headerlink" title="3.2.2. 自动应答"></a>3.2.2. 自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</strong></p><h3 id="3-2-3-消息应答的方法"><a href="#3-2-3-消息应答的方法" class="headerlink" title="3.2.3. 消息应答的方法"></a>3.2.3. 消息应答的方法</h3><ul><li>Channel.basicAck(用于肯定确认)<br> RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</li><li>Channel.basicNack(用于否定确认) </li><li>Channel.basicReject(用于否定确认)<br>与 Channel.basicNack 相比少一个参数<br> 不处理该消息了直接拒绝，可以将其丢弃了<h3 id="3-2-4-Multiple-的解释"><a href="#3-2-4-Multiple-的解释" class="headerlink" title="3.2.4. Multiple 的解释"></a>3.2.4. Multiple 的解释</h3></li></ul><p><strong>手动应答的好处是可以批量应答并且减少网络拥堵</strong><br><img src="https://img-blog.csdnimg.cn/17acbb77362543878ae867624d470e1e.png" alt="在这里插入图片描述">multiple 的 true 和 false 代表不同意思<br>true 代表批量应答 channel 上未应答的消息<br>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答<br>false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答<br><img src="https://img-blog.csdnimg.cn/6cd442a9a3f249129d1cda437c8bbe76.png" alt="在这里插入图片描述"></p><h3 id="3-2-5-消息自动重新入队"><a href="#3-2-5-消息自动重新入队" class="headerlink" title="3.2.5. 消息自动重新入队"></a>3.2.5. 消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。<br><img src="https://img-blog.csdnimg.cn/18b8f91946384a97bcb1caa16b203f26.png" alt="在这里插入图片描述"></p><h3 id="3-2-6-消息手动应答代码"><a href="#3-2-6-消息手动应答代码" class="headerlink" title="3.2.6. 消息手动应答代码"></a>3.2.6. 消息手动应答代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Work</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>        System.out.println(<span class="hljs-string">&quot;c1处理快&quot;</span>);<br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, message)-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>            <span class="hljs-comment">//手动应答</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             *  1.消息的标记 tag</span><br><span class="hljs-comment">             *  2. 是否批量应答</span><br><span class="hljs-comment">             */</span><br>            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>        &#125;;<br>        channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">false</span>,deliverCallback,(consumerTag)-&gt;&#123;<br>            System.out.println(consumerTag+<span class="hljs-string">&quot;消费取消调用接口&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-RabbitMQ-持久化"><a href="#3-3-RabbitMQ-持久化" class="headerlink" title="3.3. RabbitMQ 持久化"></a>3.3. RabbitMQ 持久化</h2><h3 id="3-3-1-概念"><a href="#3-3-1-概念" class="headerlink" title="3.3.1. 概念"></a>3.3.1. 概念</h3><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p><h3 id="3-3-2-队列如何实现持久化"><a href="#3-3-2-队列如何实现持久化" class="headerlink" title="3.3.2. 队列如何实现持久化"></a>3.3.2. 队列如何实现持久化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//是否持久化队列</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">durable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>      channel.queueDeclare(<span class="hljs-string">&quot;队列名称&quot;</span>,durable,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</p><p>以下为控制台中持久化与非持久化队列的 UI 显示区<br><img src="https://img-blog.csdnimg.cn/f1cc2a668e114d5e8e4d35c7c85a2ea0.png" alt="在这里插入图片描述">这个时候即使重启 rabbitmq 队列也依然存在</p><h3 id="3-3-3-消息实现持久化"><a href="#3-3-3-消息实现持久化" class="headerlink" title="3.3.3. 消息实现持久化"></a>3.3.3. 消息实现持久化</h3><p>要想让消息实现持久化需要在生产者中修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添加这个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//消息持久化 保存到磁盘，第三个参数</span><br>           channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());<br>           <br></code></pre></td></tr></table></figure><h3 id="3-3-4-不公平分发"><a href="#3-3-4-不公平分发" class="headerlink" title="3.3.4. 不公平分发"></a>3.3.4. 不公平分发</h3><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是RabbitMQ 并不知道这种情况它依然很公平的进行分发。<br>为了避免这种情况，我们可以在消费者中设置参数 channel.basicQos(1);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置不公平分发</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">prefetchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      channel.basicQos(prefetchCount);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b76b0653072e4108b2a34c74b2b354f6.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/704391b2ae4549e29b8c8874b357d755.png" alt="在这里插入图片描述">意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p><h3 id="3-3-5-预取值"><a href="#3-3-5-预取值" class="headerlink" title="3.3.5. 预取值"></a>3.3.5. 预取值</h3><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此<br>缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用basic.qos 方法设置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有<br>未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理<br>的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//消费者设置预取值</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">prefetchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//可以为其他数字</span><br>       channel.basicQos(prefetchCount);<br></code></pre></td></tr></table></figure><h1 id="4-发布确认"><a href="#4-发布确认" class="headerlink" title="4. 发布确认"></a>4. 发布确认</h1><h2 id="4-1-发布确认原理"><a href="#4-1-发布确认原理" class="headerlink" title="4.1. 发布确认原理"></a>4.1. 发布确认原理</h2><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h2 id="4-2-发布确认的策略"><a href="#4-2-发布确认的策略" class="headerlink" title="4.2. 发布确认的策略"></a>4.2. 发布确认的策略</h2><h3 id="4-2-1-开启发布确认的方法"><a href="#4-2-1-开启发布确认的方法" class="headerlink" title="4.2.1. 开启发布确认的方法"></a>4.2.1. 开启发布确认的方法</h3><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启发布确认</span><br>        channel.confirmSelect();<br></code></pre></td></tr></table></figure><h3 id="4-2-2-单个确认发布"><a href="#4-2-2-单个确认发布" class="headerlink" title="4.2.2. 单个确认发布"></a>4.2.2. 单个确认发布</h3><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。<br>这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>       <span class="hljs-comment">//开启发布确认</span><br>       channel.confirmSelect();<br>       <span class="hljs-comment">//声明队列</span><br>       channel.queueDeclare(<span class="hljs-string">&quot;publisher&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>       <span class="hljs-comment">//异步确认</span><br>       channel.addConfirmListener((deliveryTag,multiple)-&gt;&#123;<br>           System.out.println(<span class="hljs-string">&quot;确认成功&quot;</span>+deliveryTag);<br>       &#125;,(deliveryTag,multiple)-&gt;&#123;<br>           System.out.println(<span class="hljs-string">&quot;确认失败&quot;</span>+deliveryTag);<br>       &#125;);<br>       <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">1000</span> ; i++) &#123;<br>           channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, MessageProperties.PERSISTENT_BASIC,(i+<span class="hljs-string">&quot;&quot;</span>).getBytes());<br>           <span class="hljs-comment">//单条确认</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> channel.waitForConfirms();<br>           <span class="hljs-keyword">if</span> (b)&#123;<br>               System.out.println(<span class="hljs-string">&quot;发送成功&quot;</span>);<br>           &#125;<br><br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;消耗时间:&quot;</span>+(end-start));<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-批量确认发布"><a href="#4-2-3-批量确认发布" class="headerlink" title="4.2.3. 批量确认发布"></a>4.2.3. 批量确认发布</h3><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>       <span class="hljs-comment">//开启发布确认</span><br>       channel.confirmSelect();<br>       <span class="hljs-comment">//声明队列</span><br>       channel.queueDeclare(<span class="hljs-string">&quot;publisher&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>       <span class="hljs-comment">//异步确认</span><br>       channel.addConfirmListener((deliveryTag,multiple)-&gt;&#123;<br>           System.out.println(<span class="hljs-string">&quot;确认成功&quot;</span>+deliveryTag);<br>       &#125;,(deliveryTag,multiple)-&gt;&#123;<br>           System.out.println(<span class="hljs-string">&quot;确认失败&quot;</span>+deliveryTag);<br>       &#125;);<br>       <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">1000</span> ; i++) &#123;<br>           channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, MessageProperties.PERSISTENT_BASIC,(i+<span class="hljs-string">&quot;&quot;</span>).getBytes());<br>           <span class="hljs-comment">//批量确认</span><br>           <span class="hljs-keyword">if</span> (i%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>)&#123;<br>               <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> channel.waitForConfirms();<br>               <span class="hljs-keyword">if</span> (b)&#123;<br>                   System.out.println(<span class="hljs-string">&quot;发送成功&quot;</span>);<br>               &#125;<br>           &#125;<br><br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;消耗时间:&quot;</span>+(end-start));<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-4-异步确认发布"><a href="#4-2-4-异步确认发布" class="headerlink" title="4.2.4. 异步确认发布"></a>4.2.4. 异步确认发布</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说，他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功，下面就让我们来详细讲解异步确认是怎么实现的.<br><img src="https://img-blog.csdnimg.cn/55eec12d138a4c7aa2fa0b737afe7deb.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>       <span class="hljs-comment">//开启发布确认</span><br>       channel.confirmSelect();<br>       ConcurrentSkipListMap&lt;Long,String&gt; concurrentSkipListMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>();<br>       channel.addConfirmListener((deliveryTag,multiple)-&gt;&#123;<br>           <span class="hljs-comment">//multiple 为true表示 可以确认小于等于当前序列号的消息，false表示确认当前序列号的消息</span><br>               <span class="hljs-keyword">if</span> (multiple)&#123;<br>                   <span class="hljs-comment">/**</span><br><span class="hljs-comment">                    * concurrentSkipListMap.headMap(deliveryTag，false)</span><br><span class="hljs-comment">                    * 第二个参数默认为false，表示小于当前的deliveryTag</span><br><span class="hljs-comment">                    * true表示小于或等于当前的deliveryTag</span><br><span class="hljs-comment">                    */</span><br>                   ConcurrentNavigableMap&lt;Long, String&gt; headMap = concurrentSkipListMap.headMap(deliveryTag);<br>                   headMap.clear();<br>               &#125;<span class="hljs-keyword">else</span> &#123;<br>                   concurrentSkipListMap.remove(deliveryTag);<br>               &#125;<br>       &#125;,(deliveryTag,multiple)-&gt;&#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> concurrentSkipListMap.get(deliveryTag);<br>           System.out.println(<span class="hljs-string">&quot;未被确认的消息&quot;</span>+message);<br>       &#125;);<br>       <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> i+<span class="hljs-string">&quot;&quot;</span>;<br>           channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;publisher&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>           concurrentSkipListMap.put(channel.getNextPublishSeqNo(),message);<br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;消耗时间：&quot;</span>+(end-start)+<span class="hljs-string">&quot;ms&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-5-如何处理异步未确认消息"><a href="#4-2-5-如何处理异步未确认消息" class="headerlink" title="4.2.5. 如何处理异步未确认消息"></a>4.2.5. 如何处理异步未确认消息</h3><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递</p><h1 id="5-交换机"><a href="#5-交换机" class="headerlink" title="5. 交换机"></a>5. 交换机</h1><h2 id="5-1-Exchanges"><a href="#5-1-Exchanges" class="headerlink" title="5.1. Exchanges"></a>5.1. Exchanges</h2><h3 id="5-1-1-Exchanges-概念"><a href="#5-1-1-Exchanges-概念" class="headerlink" title="5.1.1. Exchanges 概念"></a>5.1.1. Exchanges 概念</h3><p>RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产<br>者甚至都不知道这些消息传递传递到了哪些队列中</p><p>相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。<br><img src="https://img-blog.csdnimg.cn/6b4de0c26fd34aa8a0fca22b6c4fd753.png" alt="在这里插入图片描述"></p><h3 id="5-1-2-Exchanges-的类型"><a href="#5-1-2-Exchanges-的类型" class="headerlink" title="5.1.2. Exchanges 的类型"></a>5.1.2. Exchanges 的类型</h3><p>总共有以下类型：<br>直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p><h3 id="5-1-3-无名exchange"><a href="#5-1-3-无名exchange" class="headerlink" title="5.1.3. 无名exchange"></a>5.1.3. 无名exchange</h3><p>在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,message.getBytes());<br></code></pre></td></tr></table></figure><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，</p><h2 id="5-2-临时队列"><a href="#5-2-临时队列" class="headerlink" title="5.2. 临时队列"></a>5.2. 临时队列</h2><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。<br>创建临时队列的方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br></code></pre></td></tr></table></figure><h2 id="5-3-绑定-bindings"><a href="#5-3-绑定-bindings" class="headerlink" title="5.3. 绑定(bindings)"></a>5.3. 绑定(bindings)</h2><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队<br>列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定<br><img src="https://img-blog.csdnimg.cn/f225dc3512b549a884603780beab40e8.png" alt="在这里插入图片描述"></p><h2 id="5-4-Fanout"><a href="#5-4-Fanout" class="headerlink" title="5.4. Fanout"></a>5.4. Fanout</h2><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。系统中默认有些 exchange 类型<br><img src="https://img-blog.csdnimg.cn/32d0f612a71f445991c8d06cb76c1961.png" alt="在这里插入图片描述"></p><h3 id="5-4-2-Fanout-实战"><a href="#5-4-2-Fanout-实战" class="headerlink" title="5.4.2. Fanout 实战"></a>5.4.2. Fanout 实战</h3><p><img src="https://img-blog.csdnimg.cn/fc551879ab0c4398a39e7da9fdcff3d9.png" alt="在这里插入图片描述"></p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmitLog</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br><span class="hljs-comment">//        channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;);</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> scanner.next();<br>            channel.basicPublish(EXCHANGE_NAME,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-literal">null</span>,message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;生产者发送消息：&quot;</span>+message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fanout01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>        <span class="hljs-comment">//创建临时队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//创建交换机</span><br>        channel.exchangeDeclare(EXCHANGE_NAME,<span class="hljs-string">&quot;fanout&quot;</span>);<br>        channel.queueBind(queue,EXCHANGE_NAME,<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息......&quot;</span>);<br><br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,(consumerTag,message)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;消费的消息01:&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(),<span class="hljs-string">&quot;utf-8&quot;</span>));<br>        &#125;,(consumerTag,message)-&gt;&#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-Direct-exchange"><a href="#5-5-Direct-exchange" class="headerlink" title="5.5. Direct exchange"></a>5.5. Direct exchange</h2><p><img src="https://img-blog.csdnimg.cn/84012a59693d438197b5e32de3f37e5f.png" alt="在这里插入图片描述"><br>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange，队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.<br>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃</p><h3 id="5-5-3-多重绑定"><a href="#5-5-3-多重绑定" class="headerlink" title="5.5.3. 多重绑定"></a>5.5.3. 多重绑定</h3><p><img src="https://img-blog.csdnimg.cn/0fd3688779714d3eb0d36e14cd16d2a6.png" alt="在这里插入图片描述"><br>当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。</p><h3 id="5-5-4-实战"><a href="#5-5-4-实战" class="headerlink" title="5.5.4. 实战"></a>5.5.4. 实战</h3><p><img src="https://img-blog.csdnimg.cn/8793178dea6a4419a9295763a3eb6dae.png" alt="在这里插入图片描述"><br><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dir.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> scanner.next();<br>            channel.basicPublish(EXCHANGE_NAME,<span class="hljs-string">&quot;info&quot;</span>,<span class="hljs-literal">null</span>,message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;消息发送成功:&quot;</span>+message);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Direct01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;disk&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dir.exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(EXCHANGE_NAME,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">//声明队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">disk</span> <span class="hljs-operator">=</span> channel.queueDeclare(QUEUE_NAME1, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>).getQueue();<br>        <span class="hljs-comment">//绑定</span><br>        channel.queueBind(disk,EXCHANGE_NAME,<span class="hljs-string">&quot;error&quot;</span>);<br>        <span class="hljs-comment">//消费</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (String consumerTag, Delivery message)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;c2消费的消息为：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>        &#125;;<br>        channel.basicConsume(disk,<span class="hljs-literal">true</span>,deliverCallback,(a,b)-&gt;&#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Direct02</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dir.exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(EXCHANGE_NAME,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">//声明队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">console</span> <span class="hljs-operator">=</span> channel.queueDeclare(QUEUE_NAME2, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>).getQueue();<br>        <span class="hljs-comment">//绑定</span><br>        channel.queueBind(console,EXCHANGE_NAME,<span class="hljs-string">&quot;warning&quot;</span>);<br>        channel.queueBind(console,EXCHANGE_NAME,<span class="hljs-string">&quot;info&quot;</span>);<br>        <span class="hljs-comment">//消费</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (String consumerTag, Delivery message)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;c2消费的消息为：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>        &#125;;<br>        channel.basicConsume(console,<span class="hljs-literal">true</span>,deliverCallback,(a,b)-&gt;&#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-Topics"><a href="#5-6-Topics" class="headerlink" title="5.6. Topics"></a>5.6. Topics</h2><p>尽管使用direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型</p><h3 id="5-6-2-Topic-的要求"><a href="#5-6-2-Topic-的要求" class="headerlink" title="5.6.2. Topic 的要求"></a>5.6.2. Topic 的要求</h3><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,”quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。<br>在这个规则列表中，其中有两个替换符是大家需要注意的<br>***(星号)可以代替一个单词<br>#(井号)可以替代零个或多个单词**</p><h3 id="5-6-3-Topic-匹配案例"><a href="#5-6-3-Topic-匹配案例" class="headerlink" title="5.6.3. Topic 匹配案例"></a>5.6.3. Topic 匹配案例</h3><p>下图绑定关系如下<br>Q1–&gt;绑定的是中间带 orange 带 3 个单词的字符串(<em>.orange.</em>)<br>Q2–&gt;绑定的是最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit)第一个单词是 lazy 的多个单词(lazy.#)<br><img src="https://img-blog.csdnimg.cn/74f2b3d22b724572ba390e6a42c73be9.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d64c6c32452f4fe5b771aaffcf08f53c.png" alt="在这里插入图片描述">当队列绑定关系是下列这种情况时需要引起注意</p><p><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了<br>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></p><h3 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6. 死信队列"></a>6. 死信队列</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有<br>后续的处理，就变成了死信，有死信自然就有了死信队列。应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时<br>间未支付时自动失效</p><h2 id="6-2-死信的来源"><a href="#6-2-死信的来源" class="headerlink" title="6.2. 死信的来源"></a>6.2. 死信的来源</h2><p>消息 TTL 过期<br>队列达到最大长度(队列满了，无法再添加数据到 mq 中)<br>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false</p><h2 id="6-3-死信实战"><a href="#6-3-死信实战" class="headerlink" title="6.3. 死信实战"></a>6.3. 死信实战</h2><h3 id="6-3-1-代码架构图"><a href="#6-3-1-代码架构图" class="headerlink" title="6.3.1. 代码架构图"></a>6.3.1. 代码架构图</h3><p><img src="https://img-blog.csdnimg.cn/f6cebafccf424358b6911461b9f8ac19.png" alt="在这里插入图片描述"></p><h3 id="6-3-2-消息TTL-过期"><a href="#6-3-2-消息TTL-过期" class="headerlink" title="6.3.2. 消息TTL 过期"></a>6.3.2. 消息TTL 过期</h3><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>        <span class="hljs-comment">//消息设置TTL时间</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">expiration</span> <span class="hljs-operator">=</span> String.valueOf(<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>);<br>        AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().expiration(expiration).build();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> i+<span class="hljs-string">&quot;&quot;</span>;<br>            channel.basicPublish(EXCHANGE_NORMAL,<span class="hljs-string">&quot;zhangsan&quot;</span>,properties,message.getBytes());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_DEAD=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br><br>        channel.exchangeDeclare(EXCHANGE_NORMAL, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(EXCHANGE_DEAD, BuiltinExchangeType.DIRECT);<br><br>        Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//设置过期时间为10s</span><br><span class="hljs-comment">//        arguments.put(&quot;x-message-ttl&quot;,10*1000);</span><br>        <span class="hljs-comment">//设置正常队列死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,EXCHANGE_DEAD);<br>        <span class="hljs-comment">//设置死信RoutingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">normal_queue</span> <span class="hljs-operator">=</span> channel.queueDeclare(<span class="hljs-string">&quot;normal-queue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, arguments).getQueue();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dead_queue</span> <span class="hljs-operator">=</span> channel.queueDeclare(<span class="hljs-string">&quot;dead-queue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>).getQueue();<br>        channel.queueBind(normal_queue,EXCHANGE_NORMAL,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        channel.queueBind(dead_queue,EXCHANGE_DEAD,<span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        channel.basicConsume(<span class="hljs-string">&quot;normal-queue&quot;</span>,<span class="hljs-literal">true</span>,(consumerTag,message)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者c1消费的消息为：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>        &#125;,(consumerTag,message)-&gt;&#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_DEAD=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br><br>        channel.basicConsume(<span class="hljs-string">&quot;dead-queue&quot;</span>,<span class="hljs-literal">true</span>,(consumerTag,message)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者c2消费的消息为：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>        &#125;,(consumerTag,message)-&gt;&#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-3-队列达到最大长度"><a href="#6-3-3-队列达到最大长度" class="headerlink" title="6.3.3. 队列达到最大长度"></a>6.3.3. 队列达到最大长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> i+<span class="hljs-string">&quot;&quot;</span>;<br>            channel.basicPublish(EXCHANGE_NORMAL,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-literal">null</span>,message.getBytes());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_DEAD=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br><br>        channel.exchangeDeclare(EXCHANGE_NORMAL, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(EXCHANGE_DEAD, BuiltinExchangeType.DIRECT);<br><br>        Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//设置过期时间为10s</span><br><span class="hljs-comment">//        arguments.put(&quot;x-message-ttl&quot;,10*1000);</span><br>        <span class="hljs-comment">//设置正常队列死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,EXCHANGE_DEAD);<br>        <span class="hljs-comment">//设置死信RoutingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>        <span class="hljs-comment">//设置队列最大长度</span><br>        arguments.put(<span class="hljs-string">&quot;x-max-length&quot;</span>,<span class="hljs-number">6</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">normal_queue</span> <span class="hljs-operator">=</span> channel.queueDeclare(<span class="hljs-string">&quot;normal-queue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, arguments).getQueue();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dead_queue</span> <span class="hljs-operator">=</span> channel.queueDeclare(<span class="hljs-string">&quot;dead-queue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>).getQueue();<br>        channel.queueBind(normal_queue,EXCHANGE_NORMAL,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        channel.queueBind(dead_queue,EXCHANGE_DEAD,<span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        channel.basicConsume(<span class="hljs-string">&quot;normal-queue&quot;</span>,<span class="hljs-literal">true</span>,(consumerTag,message)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者c1消费的消息为：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>        &#125;,(consumerTag,message)-&gt;&#123;&#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_DEAD=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br><br>        channel.basicConsume(<span class="hljs-string">&quot;dead-queue&quot;</span>,<span class="hljs-literal">true</span>,(consumerTag,message)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者c2消费的消息为：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>        &#125;,(consumerTag,message)-&gt;&#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-4-消息被拒"><a href="#6-3-4-消息被拒" class="headerlink" title="6.3.4. 消息被拒"></a>6.3.4. 消息被拒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> i+<span class="hljs-string">&quot;&quot;</span>;<br>            channel.basicPublish(EXCHANGE_NORMAL,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-literal">null</span>,message.getBytes());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_DEAD=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br><br>        channel.exchangeDeclare(EXCHANGE_NORMAL, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(EXCHANGE_DEAD, BuiltinExchangeType.DIRECT);<br><br>        Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//设置过期时间为10s</span><br><span class="hljs-comment">//        arguments.put(&quot;x-message-ttl&quot;,10*1000);</span><br>        <span class="hljs-comment">//设置正常队列死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,EXCHANGE_DEAD);<br>        <span class="hljs-comment">//设置死信RoutingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">normal_queue</span> <span class="hljs-operator">=</span> channel.queueDeclare(<span class="hljs-string">&quot;normal-queue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, arguments).getQueue();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dead_queue</span> <span class="hljs-operator">=</span> channel.queueDeclare(<span class="hljs-string">&quot;dead-queue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>).getQueue();<br>        channel.queueBind(normal_queue,EXCHANGE_NORMAL,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        channel.queueBind(dead_queue,EXCHANGE_DEAD,<span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        channel.basicConsume(<span class="hljs-string">&quot;normal-queue&quot;</span>, <span class="hljs-literal">false</span>, (consumerTag, message) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>            <span class="hljs-keyword">if</span> (msg.equals(<span class="hljs-string">&quot;5&quot;</span>))&#123;<br>                <span class="hljs-comment">//拒绝消息,第二个参数为false不放回正常队里，则消息将进入死信队列</span><br>                channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                System.out.println(msg+<span class="hljs-string">&quot;被拒绝&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;正常消息：&quot;</span>+msg);<br>                <span class="hljs-comment">//multiple表示是否批量应答</span><br>                channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>            &#125;<br><br>        &#125;, (consumerTag, message) -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NORMAL=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_DEAD=<span class="hljs-string">&quot;direct&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtil.getChannel();<br><br>        channel.basicConsume(<span class="hljs-string">&quot;dead-queue&quot;</span>,<span class="hljs-literal">true</span>,(consumerTag,message)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者c2消费的消息为：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>        &#125;,(consumerTag,message)-&gt;&#123;&#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="7-延迟队列"><a href="#7-延迟队列" class="headerlink" title="7. 延迟队列"></a>7. 延迟队列</h1><h2 id="7-1-延迟队列概念"><a href="#7-1-延迟队列概念" class="headerlink" title="7.1. 延迟队列概念"></a>7.1. 延迟队列概念</h2><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p><h2 id="7-2-延迟队列使用场景"><a href="#7-2-延迟队列使用场景" class="headerlink" title="7.2. 延迟队列使用场景"></a>7.2. 延迟队列使用场景</h2><p>1.订单在十分钟之内未支付则自动取消<br>2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。<br>3.用户注册成功后，如果三天内没有登陆则进行短信提醒。<br>4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。<br>5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</p><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万<br>级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。<br><img src="https://img-blog.csdnimg.cn/44dd4ce1987c43e8bc3c18be71bee998.png" alt="在这里插入图片描述"></p><h2 id="7-3-RabbitMQ-中的-TTL"><a href="#7-3-RabbitMQ-中的-TTL" class="headerlink" title="7.3. RabbitMQ 中的 TTL"></a>7.3. RabbitMQ 中的 TTL</h2><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，<br>单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的TTL 和消息的TTL，那么<strong>较小的那</strong>个值将会被使用，有两种方式设置 TTL。</p><h3 id="7-3-1-消息设置TTL"><a href="#7-3-1-消息设置TTL" class="headerlink" title="7.3.1. 消息设置TTL"></a>7.3.1. 消息设置TTL</h3><p>一种方式便是针对每条消息设置TTL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XC&quot;</span>,message,(msg -&gt;&#123;<br>              msg.getMessageProperties().setExpiration(ttla);<br>          <span class="hljs-keyword">return</span> msg;<br>      &#125; ));<br></code></pre></td></tr></table></figure><h3 id="7-3-2-队列设置TTL"><a href="#7-3-2-队列设置TTL" class="headerlink" title="7.3.2. 队列设置TTL"></a>7.3.2. 队列设置TTL</h3><p>一种是在创建队列的时候设置队列的“x-message-ttl”属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">arguments.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>,<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h3 id="7-3-3-两者的区别"><a href="#7-3-3-两者的区别" class="headerlink" title="7.3.3. 两者的区别"></a>7.3.3. 两者的区别</h3><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h3><h3 id="7-5-队列-TTL"><a href="#7-5-队列-TTL" class="headerlink" title="7.5. 队列 TTL"></a>7.5. 队列 TTL</h3><h3 id="7-5-1-代码架构图"><a href="#7-5-1-代码架构图" class="headerlink" title="7.5.1. 代码架构图"></a>7.5.1. 代码架构图</h3><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：<br><img src="https://img-blog.csdnimg.cn/5a52ca3f2da340df80a88f49cfdeab24.png" alt="在这里插入图片描述"></p><h3 id="7-5-2-配置文件类代码"><a href="#7-5-2-配置文件类代码" class="headerlink" title="7.5.2. 配置文件类代码"></a>7.5.2. 配置文件类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLQueueConfig</span> &#123;<br>    <span class="hljs-comment">//普通交换机名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">X_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;X&quot;</span>;<br>    <span class="hljs-comment">//死信交换机名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>;<br>    <span class="hljs-comment">//普通队里名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_C</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QC&quot;</span>;<br>    <span class="hljs-comment">//死信队列名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_LETTER_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QD&quot;</span>;<br><br>    <span class="hljs-meta">@Bean(&quot;queueC&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueC</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String , Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;YD&quot;</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(map).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueCBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange )</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="hljs-string">&quot;XC&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean(&quot;xExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">xExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(X_EXCHANGE);<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;yExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">yExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);<br>    &#125;<br> <br><span class="hljs-comment">//    死信队列</span><br>    <span class="hljs-meta">@Bean(&quot;queueD&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueD</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(DEAD_LETTER_QUEUE).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueDBindingY</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange )</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-5-3-消息生产者代码"><a href="#7-5-3-消息生产者代码" class="headerlink" title="7.5.3. 消息生产者代码"></a>7.5.3. 消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message)</span> &#123;<br>      log.info(<span class="hljs-string">&quot;当前时间:&#123;&#125;,发送一条信息给两个TTL队列：&#123;&#125;&quot;</span>, LocalDateTime.now(), message);<br>      rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XA&quot;</span>,<span class="hljs-string">&quot;消息来自ttl为10秒的队列&quot;</span>);<br>      rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XB&quot;</span>,<span class="hljs-string">&quot;消息来自ttl为40秒的队列&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="7-5-4-消息消费者代码"><a href="#7-5-4-消息消费者代码" class="headerlink" title="7.5.4. 消息消费者代码"></a>7.5.4. 消息消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;QD&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message mes, Channel channel)</span>&#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(mes.getBody());<br>       log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到死信队列的消息:&#123;&#125;&quot;</span>, LocalDateTime.now(),msg);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="8-1-发布确认-springboot-版本"><a href="#8-1-发布确认-springboot-版本" class="headerlink" title="8.1. 发布确认 springboot 版本"></a>8.1. 发布确认 springboot 版本</h2><h3 id="8-1-1-确认机制方案"><a href="#8-1-1-确认机制方案" class="headerlink" title="8.1.1. 确认机制方案"></a>8.1.1. 确认机制方案</h3><p><img src="https://img-blog.csdnimg.cn/382d92ba3c6942cc886ab39cde463e03.png" alt="在这里插入图片描述"></p><h3 id="8-1-2-代码架构图"><a href="#8-1-2-代码架构图" class="headerlink" title="8.1.2. 代码架构图"></a>8.1.2. 代码架构图</h3><p><img src="https://img-blog.csdnimg.cn/ce212de32a7d41de87f467c224cce469.png" alt="在这里插入图片描述"></p><h3 id="8-1-3-配置文件"><a href="#8-1-3-配置文件" class="headerlink" title="8.1.3. 配置文件"></a>8.1.3. 配置文件</h3><p>在配置文件当中需要添加<br><strong>spring.rabbitmq.publisher-confirm-type=correlated</strong><br>⚫ NONE<br>禁用发布确认模式，是默认值<br>⚫ CORRELATED<br>发布消息成功到交换器后会触发回调方法<br>⚫ SIMPLE<br>经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，<br>其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">spring.rabbitmq.host=192.168.80.130</span><br><span class="hljs-string">spring.rabbitmq.port=5672</span><br><span class="hljs-string">spring.rabbitmq.username=ydj</span><br><span class="hljs-string">spring.rabbitmq.password=123456</span><br><span class="hljs-string">spring.rabbitmq.publisher-confirm-type=correlated</span><br></code></pre></td></tr></table></figure><h3 id="8-1-4-添加配置类"><a href="#8-1-4-添加配置类" class="headerlink" title="8.1.4. 添加配置类"></a>8.1.4. 添加配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfirmConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;key1&quot;</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">confirmExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">confirmQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingExchange</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span><br><span class="hljs-params">                                        <span class="hljs-meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue)</span> &#123;<br>            <span class="hljs-keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-1-5-消息生产者"><a href="#8-1-5-消息生产者" class="headerlink" title="8.1.5. 消息生产者"></a>8.1.5. 消息生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;/confirm&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProduceController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/smg/&#123;msg&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg)</span> &#123;<br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY, msg,correlationData);<br>        log.info(<span class="hljs-string">&quot;发送的消息：&#123;&#125;&quot;</span>, msg);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="8-1-6-回调接口"><a href="#8-1-6-回调接口" class="headerlink" title="8.1.6. 回调接口"></a>8.1.6. 回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback,RabbitTemplate.ReturnsCallback &#123;<br><br>    <span class="hljs-comment">//注入</span><br><br>    <span class="hljs-meta">@Autowired</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-meta">@PostConstruct</span><span class="hljs-comment">//其他注解执行完后执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br>        rabbitTemplate.setReturnsCallback(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换机确认回调方法</span><br><span class="hljs-comment">     * 1 发消息 交换机接收到了回调</span><br><span class="hljs-comment">     * 1.1  correlationData 保存了回调消息的ID以及相关信息</span><br><span class="hljs-comment">     * 1.2 交换机接收到消息 true</span><br><span class="hljs-comment">     * 1.3 cause null</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 2 发消息 交换机接收失败了回调</span><br><span class="hljs-comment">     * 2.1  correlationData 保存回调信息的ID以及相关信息</span><br><span class="hljs-comment">     * 2.2 交换机收到消息 ack = false</span><br><span class="hljs-comment">     * 2.3 cause 失败原因</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> correlationData==<span class="hljs-literal">null</span>?<span class="hljs-string">&quot;&quot;</span>:correlationData.getId();<br>        <span class="hljs-keyword">if</span> (ack) &#123;<br>            log.info(<span class="hljs-string">&quot;交换机收到了ID为&#123;&#125;的消息&quot;</span>, id);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;交换机还未收到ID为&#123;&#125;的消息，原因是：&#123;&#125;&quot;</span>,id,cause);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;消息&#123;&#125;，被交换机&#123;&#125;退回，退回原因&#123;&#125;，路由key：&#123;&#125;&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(returned.getMessage().getBody()),<br>                returned.getExchange(),<br>                returned.getReplyText(),<br>                returned.getRoutingKey());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-1-7-消息消费者"><a href="#8-1-7-消息消费者" class="headerlink" title="8.1.7. 消息消费者"></a>8.1.7. 消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfirmMessage</span><span class="hljs-params">(Message message)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;接收到的队列confirm.queue消息：&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-回退消息"><a href="#8-2-回退消息" class="headerlink" title="8.2. 回退消息"></a>8.2. 回退消息</h2><h3 id="8-2-1-Mandatory-参数"><a href="#8-2-1-Mandatory-参数" class="headerlink" title="8.2.1. Mandatory 参数"></a>8.2.1. Mandatory 参数</h3><p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">spring.rabbitmq.host=192.168.80.130</span><br><span class="hljs-string">spring.rabbitmq.port=5672</span><br><span class="hljs-string">spring.rabbitmq.username=ydj</span><br><span class="hljs-string">spring.rabbitmq.password=123456</span><br><span class="hljs-string">spring.rabbitmq.publisher-confirm-type=correlated</span><br><span class="hljs-string">spring.rabbitmq.publisher-returns=true</span><br></code></pre></td></tr></table></figure><h3 id="8-2-2-消息生产者代码"><a href="#8-2-2-消息生产者代码" class="headerlink" title="8.2.2. 消息生产者代码"></a>8.2.2. 消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;/confirm&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProduceController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/smg/&#123;msg&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg)</span> &#123;<br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY, msg,correlationData);<br>        log.info(<span class="hljs-string">&quot;发送的消息：&#123;&#125;&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-3-回调接口"><a href="#8-2-3-回调接口" class="headerlink" title="8.2.3.回调接口"></a>8.2.3.回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback,RabbitTemplate.ReturnsCallback &#123;<br><br>    <span class="hljs-comment">//注入</span><br><br>    <span class="hljs-meta">@Autowired</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-meta">@PostConstruct</span><span class="hljs-comment">//其他注解执行完后执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br>        rabbitTemplate.setReturnsCallback(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换机确认回调方法</span><br><span class="hljs-comment">     * 1 发消息 交换机接收到了回调</span><br><span class="hljs-comment">     * 1.1  correlationData 保存了回调消息的ID以及相关信息</span><br><span class="hljs-comment">     * 1.2 交换机接收到消息 true</span><br><span class="hljs-comment">     * 1.3 cause null</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 2 发消息 交换机接收失败了回调</span><br><span class="hljs-comment">     * 2.1  correlationData 保存回调信息的ID以及相关信息</span><br><span class="hljs-comment">     * 2.2 交换机收到消息 ack = false</span><br><span class="hljs-comment">     * 2.3 cause 失败原因</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> correlationData==<span class="hljs-literal">null</span>?<span class="hljs-string">&quot;&quot;</span>:correlationData.getId();<br>        <span class="hljs-keyword">if</span> (ack) &#123;<br>            log.info(<span class="hljs-string">&quot;交换机收到了ID为&#123;&#125;的消息&quot;</span>, id);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;交换机还未收到ID为&#123;&#125;的消息，原因是：&#123;&#125;&quot;</span>,id,cause);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;消息&#123;&#125;，被交换机&#123;&#125;退回，退回原因&#123;&#125;，路由key：&#123;&#125;&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(returned.getMessage().getBody()),<br>                returned.getExchange(),<br>                returned.getReplyText(),<br>                returned.getRoutingKey());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitmq</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2022/05/09/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2022/05/09/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="芭比Q"><a href="#芭比Q" class="headerlink" title="芭比Q"></a>芭比Q</h2><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/09/hello-world/"/>
    <url>/2022/05/09/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
